-- Custom types
CREATE TYPE public.app_role AS ENUM ('admin', 'user');
CREATE TYPE public.app_permission AS ENUM ('leads.delete', 'leads.create', 'leads.edit');

-- USER ROLES
CREATE TABLE public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

-- ROLE PERMISSIONS
CREATE TABLE public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- Seed initial permissions
INSERT INTO public.role_permissions (role, permission)
VALUES
  ('admin', 'leads.delete'),
  ('admin', 'leads.create'),
  ('admin', 'leads.edit'),
  ('user', 'leads.create'),
  ('user', 'leads.edit');

-- Auth Hook to add user_role to JWT
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
BEGIN
  -- Check if the user has a role in the user_roles table
  SELECT role INTO user_role FROM public.user_roles WHERE user_id = (event->>'user_id')::uuid;

  claims := event->'claims';

  IF user_role IS NOT NULL THEN
    -- Set the user_role claim
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- Default to 'user' role if not found
    claims := jsonb_set(claims, '{user_role}', '"user"');
  END IF;

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  return event;
END;
$$;

GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
-- notify_api_restart to apply the new hook
NOTIFY pgrst, 'reload schema';


-- Authorize helper function
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
)
RETURNS boolean AS $$
DECLARE
  bind_permissions int;
  user_role public.app_role;
BEGIN
  -- Fetch user role once and store it to reduce number of calls
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;

  SELECT count(*)
  INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;

  return bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET SEARCH_PATH = '';

GRANT EXECUTE ON FUNCTION public.authorize(app_permission) TO authenticated; 